# -*- coding: utf-8 -*-
"""Untitled423.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hhKllx3ruwaD3q0qx6-KKgNBD4B3XoAI

# 1. Importing Library

Mengimport beberapa library yang akan dibutuhkan
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import zipfile
import os
import tensorflow as tf
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler

"""# 2. Data Loading

Mengunduh dataset octopustema/full-imdb-dataset dari kaggle menggunakn Kaggle API.
"""

!kaggle datasets download -d octopusteam/full-imdb-dataset

"""Selanjutnya, mengekstrak file ZIP yang diunduh ke folder bernama fullimdb-dataset"""

!unzip full-imdb-dataset -d full-imdb-dataset

df = pd.read_csv("full-imdb-dataset/data.csv")
df

"""dari data diatas terlihat 7 variabel dengan jumlah sebanyak 1037553

# 3. Data Understanding
"""

df.info()

"""dari hasil diatas, dapat dilihat bahwa:

kolom bertipe object: id, title, type, genres.

kolom bertipe float64: averageRating, numVotes, releaseYear.

kode dibawah ini untuk melihat berapa banyak entri yang unik berdasarkan title dan genres
"""

print('Banyak IMDB: ', len(df.title.unique()))
print('Genre IMDB: ', df.genres.unique())

"""Selanjutnya, memeriksa nilai 0 pada setiap kolom"""

df.isnull().sum()

"""Terdapat banyak missing value pada beberapa kolom seperti genres, averageRating, numVotes, releaseYear. untuk kolom title ada sedikit missing value.

kode dibawah untuk mengecek apakah ada duplikat
"""

df.duplicated().sum()

"""hasil dari kode diatas adalah 0 yang merarti tidak ada data duplikat dalam dataset ini.

Selanjutnya, Memeriksa Outlier pada kolom Numerik
"""

sns.boxplot(x = df["numVotes"])

"""ada banyak outlier pada kolom numVotes"""

sns.boxplot(x = df["averageRating"])

"""Bisa dilihat dari visualisasi diatas, terdapat outlier pada kolom averageRating"""

sns.boxplot(x = df["releaseYear"])

"""pada kolom releaseYear juga ada outlier

# 4. Data Preparation dan univariate analysis

kode dibawah ini untuk membersihkan missing value dengan fungsi dropna()
"""

df = df.dropna()
df.isnull().sum()

"""data sudah bersih dari missing value

Terlihat bahwa terdapat outlier pada semua kolom numerik. dalam kasus ini, kita akan menghapus outlier menggunakan teknik **Interquartile Range (IQR)**. IQR dihitung sebagai:

IQR=Q3−Q1

dengan:

Batas Bawah:
Q1−1.5*IQR

Batas Atas:
Q3+1.5*IQR

Outlier adalah nilai yang berada di luar batas ini, dan akan dihapus dari dataset.
"""

numeric_columns = df.select_dtypes(include = ["number"]).columns

Q1 = df[numeric_columns].quantile(0.25)
Q3 = df[numeric_columns].quantile(0.75)
IQR = Q3 - Q1

df = df[~((df[numeric_columns] < (Q1 - 1.5 * IQR)) |
         (df[numeric_columns] > (Q3 + 1.5 * IQR))).any(axis =1)]

df.shape

"""setelah outlier dihapus dengan teknik IQR, data menyisahkan 338158 baris dan 7 kolom"""

def reduce_memory(data):
    for col in data.columns:
        if data[col].dtype == 'float64':
            data[col] = data[col].astype('float32')
        elif data[col].dtype == 'int64':
            data[col] = data[col].astype('int32')
    return data

"""kode diatas untuk bertujuan untuk mengurangi penggunaan memori pada dataframe. tipe data float64 diubah menjadi float32. dengan perubahan ini, ukuran memori yang digunakan menjadi lebih kecil. sementara isi data tetap sama."""

df = reduce_memory(df)

"""df diproses dengan fungsi reduce_memory yang sebelumnya dijelaskan, sehingga tipe data kolom-kolomnya diubah untuk mengurangi penggunaan memori."""

df = df.sample(frac=0.05, random_state=42)

"""df diambil sampel acak sebesar 5% dari total data (ditentukan oleh frac=0.05). Argumen random_state=42 memastikan pengambilan sampel acak ini konsisten setiap kali kode dijalankan."""

df.shape

"""terlihat ukuran df memiliki 16908 baris dan 7 kolom"""

print(df['genres'].value_counts())

"""Kolom genres menunjukkan kategori atau kombinasi genre dari data.

Genre yang paling umum adalah Drama (2950 film).

Kombinasi genre seperti "Drama, Romance" dan "Comedy, Drama" juga cukup banyak.
"""

df.info()

"""hasil diatas informasi struktur dataframe yang memiliki 7 kolom, dengan 3 kolom float32 dan 4 kolom bertipe object. dan ukuran memori setelah pengolahan adalah 858.6+ KB, lebih kecil dari sebelumnya yang berukuran 55.4+ MB"""

df.describe()

"""averageRating:

Rata-rata rating film adalah 6.44, dengan nilai minimum 2.7 dan maksimum 10.

numVotes:

Jumlah suara rata-rata adalah 98, dengan minimum 5 suara dan maksimum hampir 670 suara.

releaseYear:

Rata-rata tahun rilis adalah 2002.53, dengan rentang dari 1945 hingga 2025.
"""

numerical_cols = df.select_dtypes(include=['float32']).columns
categorical_cols = df.select_dtypes(include=['object']).columns

"""kode diatas:
memilih kolom dengan tipe data float32 dan hasilny adalah daftar nama kolom numerik.

memilih kolom dengan tipe data object dan hasilnya adalah daftar nama kolom kategorikal.

kode dibawah ini pada Loop pertama memplot histogram untuk setiap kolom numerik (float32) di DataFrame.

Menggunakan sns.histplot untuk membuat histogram dengan distribusi kernel density estimation (KDE).

Setiap histogram menunjukkan distribusi nilai (misalnya, rating, jumlah suara, tahun rilis).
"""

for col in numerical_cols:
    plt.figure(figsize=(10, 6))
    sns.histplot(df[col], kde=True, bins=30, color='blue')
    plt.title(f"Distribution of {col}", fontsize=16)
    plt.xlabel(col, fontsize=12)
    plt.ylabel("Frequency", fontsize=12)
    plt.grid(axis='y')
    plt.show()

"""Hasil:

Grafik distribusi untuk:

averageRating — biasanya berbentuk lonceng, menunjukkan persebaran rating film.

numVotes — sering kali miring ke kanan (positively skewed), karena ada banyak film dengan suara rendah dan beberapa dengan suara sangat tinggi.

releaseYear — bisa menunjukkan pola historis dalam data (misalnya, lebih banyak film rilis setelah tahun tertentu).

kode di bawah pada Loop kedua memplot bar chart untuk 10 kategori teratas dalam setiap kolom kategorikal (object).

Menggunakan value_counts().head(10) untuk mendapatkan frekuensi 10 nilai paling umum.

sns.barplot memvisualisasikan jumlah setiap kategori.
"""

for col in categorical_cols:
    plt.figure(figsize=(10, 6))
    value_counts = df[col].value_counts().head(10)
    sns.barplot(x=value_counts.values, y=value_counts.index, hue=value_counts.index, dodge=False, palette="viridis", legend=False)
    plt.title(f"Top Categories in {col}", fontsize=16)
    plt.xlabel("Count", fontsize=12)
    plt.ylabel(col, fontsize=12)
    plt.grid(axis='x')
    plt.show()

"""Hasil:

Grafik bar horizontal untuk setiap kolom kategorikal, seperti:

genres — menunjukkan genre yang paling sering muncul.

type — jika ada, biasanya menunjukkan kategori seperti film, serial, atau dokumenter.

title atau id — mungkin tidak terlalu informatif jika nilai sangat unik.

# 5. Content Based Filtering
"""

tf = TfidfVectorizer()
tf.fit(df['genres'])
tf.get_feature_names_out()

"""kode diatas ini menggunakan tfidVectorizer untuk memproses teks pada kolom genres dan mengubahnya menjadi representasi vektor berdasarkan bobot TF-IDF. Prosesnya dimulai dengan melatih model TF-IDF pada data genres, sehingga model mengenali semua kata unik yang ada. Kemudian, dengan tf.get_feature_names_out(), dihasilkan daftar kata-kata unik yang ditemukan, seperti action, comedy, drama, hingga subkategori seperti sci, fi, dan talk. Hasil ini berguna untuk analisis teks lebih lanjut, seperti menghitung kemiripan genre atau membuat model prediksi berdasarkan genre."""

tfidf_matrix = tf.fit_transform(df['genres'])
tfidf_matrix.shape

"""Kode diatas menghasilkan matriks TF-IDF dengan ukuran (16908, 32)."""

tfidf_matrix.todense()

"""Kode di atas mengubah matriks TF-IDF yang awalnya berbentuk sparse (berisi banyak nilai nol) menjadi bentuk dense (matriks penuh).

Hasilnya adalah sebuah matriks dua dimensi di mana:

- Setiap baris mewakili satu film.
- Setiap kolom mewakili kata atau fitur yang terdapat dalam genre film.

Nilai-nilai dalam matriks menunjukkan skor TF-IDF untuk setiap kata di setiap film. Sebagian besar nilainya tetap nol, menunjukkan bahwa kata tersebut tidak relevan untuk genre film tertentu.

Sebagai contoh, pada matriks ini, terdapat nilai 1.0 pada baris terakhir di kolom tertentu. Ini menunjukkan bahwa kata tertentu memiliki bobot TF-IDF penuh dalam genre film terakhir, sementara kolom lainnya memiliki nilai 0, yang berarti kata-kata tersebut tidak muncul di genre film tersebut.
"""

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=df.title
).sample(22, axis=1).sample(10, axis=0)

"""kode diatas adalah sebuah DataFrame yang berisi representasi TF-IDF untuk genre-genre film di kolom genres, dengan baris yang menunjukkan judul film dan kolom yang menunjukkan kata-kata genre yang ditemukan dalam dataset.

Di dalamnya terdapat 10 baris yang mewakili 10 judul film, dan 22 kolom yang mewakili 22 kata unik atau genre (misalnya, family, adventure, talk, dll.).
Nilai dalam matriks menunjukkan seberapa penting sebuah genre (kolom) untuk setiap film (baris) berdasarkan perhitungan TF-IDF. Nilai 0 berarti genre tersebut tidak muncul dalam film tersebut, sementara nilai yang lebih tinggi menunjukkan genre tersebut memiliki kontribusi yang lebih besar terhadap film tersebut.

Misalnya, Pada film "Hogan," nilai 0.785408 di kolom sport menunjukkan bahwa genre "sport" sangat relevan untuk film tersebut. Sementara di film "Peacemaker Kurogane: Omo-michi," terdapat nilai 0.583637 di kolom action, menandakan bahwa genre "action" adalah salah satu aspek penting dari film tersebut.

Dengan cara ini, kita bisa melihat seberapa relevan setiap genre terhadap film tertentu berdasarkan perhitungan TF-IDF.
"""

from sklearn.metrics.pairwise import cosine_similarity
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""kode diatas menggunakan cosine_similarity untuk menghitung kemiripan antar film berdasarkan representasi TF-IDF yang dihasilkan sebelumnya

asilnya adalah matriks cosine similarity yang menunjukkan seberapa mirip setiap pasangan film. Nilai 1.0 menunjukkan bahwa dua film sangat mirip (misalnya, film yang sama), sementara nilai mendekati 0 berarti film tersebut sangat berbeda.
"""

cosine_sim_df = pd.DataFrame(cosine_sim, index=df['title'], columns=df['title'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Kode di atas mengubah matriks cosine similarity yang sebelumnya dihitung menjadi sebuah DataFrame dengan baris dan kolom yang mewakili judul film. Dimensi DataFrame ini adalah (16908, 16908), yang menunjukkan bahwa ada 16,908 film, dan setiap film dibandingkan dengan film lainnya untuk menghitung tingkat kemiripan berdasarkan genre mereka.

Hasil dari cosine_sim_df.sample(5, axis=1).sample(10, axis=0) menampilkan sampel acak dari matriks tersebut. Setiap nilai dalam matriks ini menunjukkan tingkat kemiripan antar film. Sebagai contoh, untuk film "Polovodye", kemiripan dengan film lainnya, seperti "Rama Chakkani Seetha", mencapai 1.0, yang berarti kedua film tersebut sangat mirip, sementara film lainnya memiliki nilai lebih rendah, menunjukkan tingkat kemiripan yang lebih rendah.
"""

def df_recommendations(judul_df, similarity_data=cosine_sim_df, items=df[['title', 'genres']], k=5):

    index = similarity_data.loc[:,judul_df].to_numpy().argpartition(
        range(-1, -k, -1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    closest = closest.drop(judul_df, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""kode diatas:

Fungsi df_recommendations digunakan untuk memberikan rekomendasi film berdasarkan kemiripan genre, yang dihitung sebelumnya menggunakan cosine similarity. Fungsi ini menerima beberapa parameter, seperti judul film yang ingin diberikan rekomendasi (misalnya, judul_df), data kemiripan (default-nya cosine_sim_df), dan daftar film yang berisi judul dan genre (default-nya adalah kolom title dan genres dari DataFrame df).

Prosesnya dimulai dengan mencari indeks film-film yang paling mirip dengan judul_df dalam matriks kemiripan, lalu memilih k film teratas yang memiliki nilai kemiripan tertinggi. Film yang sama dengan judul_df akan dihapus dari hasil rekomendasi, dan hasilnya akan ditampilkan bersama dengan informasi judul dan genre.
"""

df[df.title.eq('AstroLOLogy')]

"""hasilnya adalah informasi tentang film berjudul "AstroLOLogy", yang merupakan film dengan genre Adventure, Animation, Comedy, memiliki rating rata-rata 9.1, dan dirilis pada tahun 2017."""

result = df_recommendations('AstroLOLogy')
result

"""berdasarkan kemiripan genre dengan film "AstroLOLogy". Semua film yang direkomendasikan memiliki genre yang sama, yaitu Adventure, Animation, Comedy, dan film-film tersebut adalah:

Norm of the North: Family Vacation, ToonMarty, Tom and Jerry in New York, Work it Out Wombats!, Thomas & Friends: Sodor's Legend of the Lost Treasure
"""

a = 0

for row in result.itertuples():
  if (row.genres == 'Adventure', 'Animation', 'Comedy'):
    a += 1

precision = (a/5)*100
print("The precision of the model is {}%".format(precision))

"""Hasil yang dicetak, yaitu 100.0%, menunjukkan bahwa seluruh film dalam hasil rekomendasi memiliki genre yang termasuk dalam daftar yang diperiksa, sehingga presisi model adalah 100%.

Namun, jika genre film yang direkomendasikan tidak memenuhi kriteria tersebut, maka presisi akan lebih rendah.
"""